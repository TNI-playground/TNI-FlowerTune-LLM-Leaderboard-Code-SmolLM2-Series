[["#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Check if the vector contains any two numbers closer to each other than\n    // given threshold.\n    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        if (it->first < threshold && it->second > threshold) {\n            return true;\n        }\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> separated_paren_groups;\n    std::string paren_string = paren_string;\n    std::string paren_group = paren_string.substr(0, paren_string.find('('));\n    std::string paren_group = paren_string.substr(paren_string.find(')') + 1, paren_string.length());\n    std::string paren_group_string = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_string_replace = paren_group;\n    std::string paren_group_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    return (number - (number / 100.0f)) / 100.0f;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long max_balance = 0;\n    for (long i = 0; i < operations.size(); i++) {\n        if (operations[i] > max_balance) {\n            max_balance = operations[i];\n        }\n    }\n    return max_balance <= 0;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = 0.0f;\n    for (int i = 0; i < numbers.size(); i++) {\n        mean += numbers[i];\n    }\n    mean /= numbers.size();\n    return mean;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> numbers_intersected;\n    std::vector<long> numbers_intersected_delimiter;\n    for (auto& number : numbers) {\n        if (number % delimeter == 0) {\n            numbers_intersected.push_back(number);\n        }\n    }\n    for (auto& number : numbers_intersected) {\n        numbers_intersected_delimiter.push_back(number);\n    }\n    return numbers_intersected;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::string::size_type pos = paren_string.find('(');\n    if (pos != std::string::npos) {\n        std::string paren_string = paren_string.substr(0, pos);\n        std::string paren_string_split = paren_string.substr(pos + 1);\n        std::string paren_string_split_list = paren_string_split.split(' ');\n        for (std::string::size_type i = 0; i < paren_string_split_list.size(); i++) {\n            long l = paren_string_split_list[i];\n            long r = paren_string_split_list[i + 1];\n            long l_pos = l - 1;\n            long r_pos = r - 1;\n            long l_depth = l - l_pos;\n            long r_depth = r - r_pos;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long l_level = l_depth;\n            long r_level = r_depth;\n            long"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (auto number : numbers) {\n        sum += number;\n        product *= number;\n    }\n    return {sum, product};"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    long max_val = 0;\n    for (long i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max_val) {\n            max_val = numbers[i];\n        }\n    }\n    return numbers;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    std::string result = \"\";\n    std::string prefix = \"\";\n    std::string reverse_prefix = \"\";\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == ' ') {\n            string[i] = '0';\n            string.erase(i, 1);\n        }\n        else {\n            if (string[i] == '0') {\n                string[i] = '0';\n                string.erase(i, 1);\n            }\n            else {\n                string[i] = string[i] + '0';\n            }\n        }\n    }\n    reverse_prefix = string.substr(0, string.length() - 1);\n    prefix = string.substr(0, prefix.length() - 1);\n    reverse_prefix = prefix + reverse_prefix;\n    return result + prefix + reverse_prefix;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += a[i];\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    std::string longest = \"\";\n    for (auto& s : strings) {\n        if (s.length() > longest.length()) {\n            longest = s;\n        }\n    }\n    return longest;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    long res = 0;\n    long a_div = a;\n    long b_div = b;\n    while (a_div != 0 && b_div != 0) {\n        long a_div = a_div / b;\n        long b_div = b_div / a_div;\n        long res = a_div * b_div + b_div * a_div;\n        a_div = a_div % b;\n        b_div = b_div % a_div;\n    }\n    if (a_div == 0) {\n        res = b_div;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> all_prefixes;\n    std::string prefix;\n    std::string longest_prefix;\n    std::string longest_suffix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix;\n    std::string longest_suffix_prefix"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::string result;\n    for (long i = 0; i < n; i++) {\n        result += '0';\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::vector<std::string> words;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == ' ') {\n            words.push_back(string.substr(i, string.size() - i));\n        }\n    }\n    std::sort(words.begin(), words.end());\n    return words.size();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> notes;\n    std::stringstream stream(music_string);\n    std::string note;\n    while (std::getline(stream, note, ' ')) {\n        if (note.size() == 4) {\n            notes.push_back(std::stoi(note));\n        }\n    }\n    return notes;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    int len = string.length();\n    int count = 0;\n    int i = 0;\n    while (i < len) {\n        if (substring.find(string[i]) != std::string::npos) {\n            count++;\n        }\n        i++;\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::string result = \"\";\n    int i = 0;\n    int j = 0;\n    while (i < numbers.length()) {\n        if (numbers[i] < numbers[j]) {\n            result += numbers[i];\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::vector<std::tuple<float, float>> result;\n  std::set<std::tuple<float, float>>::iterator it;\n  for (it = numbers.begin(); it != numbers.end(); ++it) {\n    if (it == numbers.begin()) {\n      continue;\n    }\n    if (it == numbers.begin() + 1) {\n      continue;\n    }\n    if (it == numbers.begin() + 2) {\n      continue;\n    }\n    if (it == numbers.begin() + 3) {\n      continue;\n    }\n    if (it == numbers.begin() + 4) {\n      continue;\n    }\n    if (it == numbers.begin() + 5) {\n      continue;\n    }\n    if (it == numbers.begin() + 6) {\n      continue;\n    }\n    if (it == numbers.begin() + 7) {\n      continue;\n    }\n    if (it == numbers.begin() + 8) {\n      continue;\n    }\n    if (it == numbers.begin() + 9) {\n      continue;\n    }\n    if (it == numbers.begin() + 10) {\n      continue;\n    }\n    if (it == numbers.begin() + 11) {\n      continue;\n    }\n    if (it == numbers.begin() + 12) {\n      continue;\n    }\n    if (it == numbers.begin() + 13) {\n      continue;\n    }\n    if (it == numbers.begin() + 14) {\n      continue;\n    }\n    if (it == numbers.begin() + 15) {\n      continue;\n    }\n    if (it == numbers.begin() + 16) {\n      continue;\n    }\n    if (it == numbers.begin() + 17) {\n      continue;\n    }\n    if (it == numbers.begin() + 18) {\n      continue;\n    }\n    if (it == numbers.begin() + 19) {\n      continue;\n    }\n    if (it == numbers.begin() + 20) {\n      continue;\n    }\n    if (it == numbers.begin() + 21) {\n      continue;\n    }\n    if (it == numbers.begin() + 22) {\n      continue;\n    }\n    if (it == numbers.begin() + 23) {\n      continue;\n    }\n    if (it == numbers.begin() + 24) {\n      continue;\n    }\n    if (it == numbers.begin() + 25) {\n      continue;\n    }\n    if (it == numbers.begin() + 26) {\n      continue;\n    }\n    if (it == numbers.begin() + 27) {\n      continue;\n    }\n    if (it == numbers.begin() + 28) {\n      continue;\n    }\n    if (it == numbers.begin() + 29) {\n      continue;\n    }\n    if (it == numbers.begin() + 30) {\n      continue;\n    }\n    if (it == numbers.begin() + 31) {\n      continue;\n    }\n    if (it == numbers.begin() + 32) {\n      continue;\n    }\n    if (it == numbers.begin() + 33) {\n      continue;\n    }\n    if (it == numbers.begin() + 34) {\n      continue;\n    }\n    if (it == numbers.begin() + 35) {\n      continue;\n    }\n    if (it == numbers.begin()"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float> res;\n    for (int i = 0; i < numbers.size(); i++) {\n        res.push_back(numbers[i] - (float)numbers[i]);\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == \"long\") {\n            result.push_back(it->value());\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    int len = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == ' ') {\n            len++;\n        }\n    }\n    return len;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 0;\n    long divisor = 1;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;\n    long divisor_count = 0;\n    long divisor_sum = 0;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long i;\n    for (i = 0; i < n; i++) {\n        factors.push_back(n);\n    }\n    std::sort(factors.begin(), factors.end());\n    return factors;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        if (numbers[i] != numbers[i + 1]) {\n            result.push_back(numbers[i]);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::string result = string;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] >= 'a' && string[i] <= 'z') {\n            result[i] = 'A' + string[i];\n        } else if (string[i] >= 'A' && string[i] <= 'Z') {\n            result[i] = 'a' + string[i];\n        } else {\n            result[i] = 'a' + string[i];\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (auto& s : strings) {\n        result += s;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (auto& s : strings) {\n        if (s.find(prefix) != std::string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> v;\n    for (long i = 0; i < l.size(); i++) {\n        v.push_back(l[i]);\n    }\n    return v;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    if (n % 3 == 0) {\n        return false;\n    }\n    if (n % 5 == 0) {\n        return false;\n    }\n    if (n % 7 == 0) {\n        return false;\n    }\n    if (n % 11 == 0) {\n        return false;\n    }\n    if (n % 13 == 0) {\n        return false;\n    }\n    if (n % 17 == 0) {\n        return false;\n    }\n    if (n % 19 == 0) {\n        return false;\n    }\n    if (n % 21 == 0) {\n        return false;\n    }\n    if (n % 23 == 0) {\n        return false;\n    }\n    if (n % 27 == 0) {\n        return false;\n    }\n    if (n % 31 == 0) {\n        return false;\n    }\n    if (n % 37 == 0) {\n        return false;\n    }\n    if (n % 39 == 0) {\n        return false;\n    }\n    if (n % 41 == 0) {\n        return false;\n    }\n    if (n % 43 == 0) {\n        return false;\n    }\n    if (n % 47 == 0) {\n        return false;\n    }\n    if (n % 51 == 0) {\n        return false;\n    }\n    if (n % 53 == 0) {\n        return false;\n    }\n    if (n % 57 == 0) {\n        return false;\n    }\n    if (n % 61 == 0) {\n        return false;\n    }\n    if (n % 63 == 0) {\n        return false;\n    }\n    if (n % 67 == 0) {\n        return false;\n    }\n    if (n % 71 == 0) {\n        return false;\n    }\n    if (n % 73 == 0) {\n        return false;\n    }\n    if (n % 77 == 0) {\n        return false;\n    }\n    if (n % 81 == 0) {\n        return false;\n    }\n    if (n % 83 == 0) {\n        return false;\n    }\n    if (n % 87 == 0) {\n        return false;\n    }\n    if (n % 91 == 0) {\n        return false;\n    }\n    if (n % 93 == 0) {\n        return false;\n    }\n    if (n % 97 == 0) {\n        return false;\n    }\n    if (n % 101 == 0) {\n        return false;\n    }\n    if (n % 103 == 0) {\n        return false;\n    }\n    if (n % 107 == 0) {\n        return false;\n    }\n    if (n % 111 == 0) {\n        return false;\n    }\n    if (n % 113 == 0) {\n        return false;\n    }\n    if (n % 119 == 0) {\n        return false;\n    }\n    if (n % 121 == 0) {\n        return false;\n    }\n    if (n % 123 == 0) {\n        return false;\n    }\n    if (n % 127 == 0) {\n        return false;\n    }\n    if (n % 131 == 0) {\n        return false;\n    }\n    if (n % 133 == 0) {\n        return false;\n    }\n    if (n % 137 == 0) {\n        return false;\n    }\n    if (n % 141 == 0) {\n       "], ["#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_copy(l.begin(), l.end());\n    std::sort(l_copy.begin(), l_copy.end());\n    return l_copy;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::vector<long> res(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        res[i] = l[i];\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max_val = 0;\n    for (long i = 0; i < l.size(); i++) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long fizz_buzz_count = 0;\n    long fizz_buzz_count_1 = 0;\n    long fizz_buzz_count_2 = 0;\n    long fizz_buzz_count_3 = 0;\n    long fizz_buzz_count_4 = 0;\n    long fizz_buzz_count_5 = 0;\n    long fizz_buzz_count_6 = 0;\n    long fizz_buzz_count_7 = 0;\n    long fizz_buzz_count_8 = 0;\n    long fizz_buzz_count_9 = 0;\n    long fizz_buzz_count_10 = 0;\n    long fizz_buzz_count_11 = 0;\n    long fizz_buzz_count_12 = 0;\n    long fizz_buzz_count_13 = 0;\n    long fizz_buzz_count_14 = 0;\n    long fizz_buzz_count_15 = 0;\n    long fizz_buzz_count_16 = 0;\n    long fizz_buzz_count_17 = 0;\n    long fizz_buzz_count_18 = 0;\n    long fizz_buzz_count_19 = 0;\n    long fizz_buzz_count_20 = 0;\n    long fizz_buzz_count_21 = 0;\n    long fizz_buzz_count_22 = 0;\n    long fizz_buzz_count_23 = 0;\n    long fizz_buzz_count_24 = 0;\n    long fizz_buzz_count_25 = 0;\n    long fizz_buzz_count_26 = 0;\n    long fizz_buzz_count_27 = 0;\n    long fizz_buzz_count_28 = 0;\n    long fizz_buzz_count_29 = 0;\n    long fizz_buzz_count_30 = 0;\n    long fizz_buzz_count_31 = 0;\n    long fizz_buzz_count_32 = 0;\n    long fizz_buzz_count_33 = 0;\n    long fizz_buzz_count_34 = 0;\n    long fizz_buzz_count_35 = 0;\n    long fizz_buzz_count_36 = 0;\n    long fizz_buzz_count_37 = 0;\n    long fizz_buzz_count_38 = 0;\n    long fizz_buzz_count_39 = 0;\n    long fizz_buzz_count_40 = 0;\n    long fizz_buzz_count_41 = 0;\n    long fizz_buzz_count_42 = 0;\n    long fizz_buzz_count_43 = 0;\n    long fizz_buzz_count_44 = 0;\n    long fizz_buzz_count_45 = 0;\n    long fizz_buzz_count_46 = 0;\n    long fizz_buzz_count_47 = 0;\n    long fizz_buzz_count_48 = 0;\n    long fizz_buzz_count_49 = 0;\n    long fizz_buzz_count_50 = 0;\n    long fizz_buzz_count_51 = 0;\n    long fizz_buzz_count_52 = 0;\n    long fizz_buzz_count_53 = 0;\n    long fizz_buzz_count_54 = 0;\n    long fizz_buzz_count_55 = 0;\n    long fizz_buzz_count_56 = 0;\n    long fizz_buzz_count_57 ="], ["#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n\tstd::vector<long> l_even(l.size(), 0);\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tl_even[l.at(i)] = l.at(i);\n\t}\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tlong tmp = l.at(i);\n\t\tl.at(i) = l_even[tmp];\n\t\tl_even[tmp] = l.at(i);\n\t}\n\treturn l;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib_sum = 0;\n    long fib_sum_prime = 0;\n    long fib_sum_prime_prime = 0;\n    long fib_sum_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n    long fib_sum_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  long sum = 0;\n  for (long i = 0; i < l.size(); i++) {\n    sum += l[i];\n  }\n  return sum == 0;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    long x = i * 2;\n    long y = i * 2 + 1;\n    long dx = x - y;\n    long dy = x - y;\n    long distance = dx * dx + dy * dy;\n    if (distance > 1000000000) {\n      count++;\n    }\n  }\n  return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> res(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        res[i] = l[i] + 1;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  long sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += l[i];\n  }\n  return sum == 0;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    int i = 0;\n    while (x > 0) {\n        if (x % base == 0) {\n            result.push_back(x % base);\n            x /= base;\n        }\n        i++;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    float area = 0;\n    float side = a / 2;\n    float height = h / 2;\n    float area_h = (a * side) / 2;\n    float area_l = (a * side) / 2;\n    float area_r = (a * side) / 2;\n    float area_b = (a * side) / 2;\n    float area_c = (a * side) / 2;\n    float area_d = (a * side) / 2;\n    float area_e = (a * side) / 2;\n    float area_f = (a * side) / 2;\n    float area_g = (a * side) / 2;\n    float area_h = (a * side) / 2;\n    float area_i = (a * side) / 2;\n    float area_j = (a * side) / 2;\n    float area_k = (a * side) / 2;\n    float area_l = (a * side) / 2;\n    float area_m = (a * side) / 2;\n    float area_n = (a * side) / 2;\n    float area_o = (a * side) / 2;\n    float area_p = (a * side) / 2;\n    float area_q = (a * side) / 2;\n    float area_r = (a * side) / 2;\n    float area_s = (a * side) / 2;\n    float area_t = (a * side) / 2;\n    float area_u = (a * side) / 2;\n    float area_v = (a * side) / 2;\n    float area_w = (a * side) / 2;\n    float area_x = (a * side) / 2;\n    float area_y = (a * side) / 2;\n    float area_z = (a * side) / 2;\n    float area_w = (a * side) / 2;\n    float area_h = (a * side) / 2;\n    float area_i = (a * side) / 2;\n    float area_j = (a * side) / 2;\n    float area_k = (a * side) / 2;\n    float area_l = (a * side) / 2;\n    float area_m = (a * side) / 2;\n    float area_n = (a * side) / 2;\n    float area_o = (a * side) / 2;\n    float area_p = (a * side) / 2;\n    float area_q = (a * side) / 2;\n    float area_r = (a * side) / 2;\n    float area_s = (a * side) / 2;\n    float area_t = (a * side) / 2;\n    float area_u = (a * side) / 2;\n    float area_v = (a * side) / 2;\n    float area_w = (a * side) / 2;\n    float area_x = (a * side) / 2;\n    float area_y = (a * side) / 2;\n    float area_z = (a * side) / 2;\n    float area_w = (a * side) / 2;\n    float area_h = (a * side) / 2;\n    float area_i = (a * side) / 2;\n    float area_j = (a * side) / 2;\n    float area_k = (a * side) / 2;\n    float area_l = (a * side) / 2;\n    float area_m = (a * side) / 2;\n    float area_n = (a * side) / 2;\n    float area_o = (a * side) / 2;\n    float area_p = (a * side) / 2;\n    float area_q = (a * side) / 2;\n    float area_r = (a * side) / 2;\n    float area_s = (a * side) / 2;\n    float area_t = (a * side) / 2;\n    float"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    if (n == 2) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        return fib4(n / 2);\n    }\n    return fib4(n / 2);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    long sum = 0;\n    long max = 0;\n    for (long i = 0; i < l.size(); i++) {\n        sum += l[i];\n        if (sum > max) {\n            max = sum;\n            max_index = i;\n        }\n    }\n    return (max_index - max) / (max - max_index);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    std::string str = text;\n    std::string::size_type pos = str.find_first_of(' ');\n    if (pos != std::string::npos) {\n        return true;\n    }\n    else {\n        return false;\n    }"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    long res = 1;\n    for (long i = 0; i < n; i++) {\n        res = res * p % n;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string result = text;\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] != 'a' && text[i] != 'e' && text[i] != 'i' && text[i] != 'o' && text[i] != 'u' && text[i] != 'y') {\n            result.erase(result.begin() + i);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (auto i = 0; i < l.size(); ++i) {\n        if (l[i] < t) {\n            return true;\n        }\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    long res = 0;\n    while (x != 0) {\n        res += (x % 10);\n        x /= 10;\n    }\n    while (y != 0) {\n        res += (y % 10);\n        y /= 10;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::string s2 = s0;\n    std::string s3 = s1;\n    std::string s4 = s2;\n    std::string s5 = s3;\n    std::string s6 = s4;\n    std::string s7 = s5;\n    std::string s8 = s6;\n    std::string s9 = s7;\n    std::string s10 = s8;\n    std::string s11 = s9;\n    std::string s12 = s10;\n    std::string s13 = s11;\n    std::string s14 = s12;\n    std::string s15 = s13;\n    std::string s16 = s14;\n    std::string s17 = s15;\n    std::string s18 = s16;\n    std::string s19 = s17;\n    std::string s20 = s18;\n    std::string s21 = s19;\n    std::string s22 = s20;\n    std::string s23 = s21;\n    std::string s24 = s22;\n    std::string s25 = s23;\n    std::string s26 = s24;\n    std::string s27 = s25;\n    std::string s28 = s26;\n    std::string s29 = s27;\n    std::string s30 = s28;\n    std::string s31 = s29;\n    std::string s32 = s30;\n    std::string s33 = s31;\n    std::string s34 = s32;\n    std::string s35 = s33;\n    std::string s36 = s34;\n    std::string s37 = s35;\n    std::string s38 = s36;\n    std::string s39 = s37;\n    std::string s40 = s38;\n    std::string s41 = s39;\n    std::string s42 = s40;\n    std::string s43 = s41;\n    std::string s44 = s42;\n    std::string s45 = s43;\n    std::string s46 = s44;\n    std::string s47 = s45;\n    std::string s48 = s46;\n    std::string s49 = s47;\n    std::string s50 = s48;\n    std::string s51 = s49;\n    std::string s52 = s50;\n    std::string s53 = s51;\n    std::string s54 = s52;\n    std::string s55 = s53;\n    std::string s56 = s54;\n    std::string s57 = s55;\n    std::string s58 = s56;\n    std::string s59 = s57;\n    std::string s60 = s58;\n    std::string s61 = s59;\n    std::string s62 = s60;\n    std::string s63 = s61;\n    std::string s64 = s62;\n    std::string s65 = s63;\n    std::string s66 = s64;\n    std::string s67 = s65;\n    std::string s68 = s66;\n    std::string s69 = s67;\n    std::string s70 = s68;\n    std::string s71 = s6"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    long ret = 0;\n    for (long i = 0; i < n; i++) {\n        ret += fib(i);\n    }\n    return ret;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket = 0;\n    int w_bracket = 0;\n    int x_bracket = 0;\n    int y_bracket = 0;\n    int z_bracket = 0;\n    int t_bracket = 0;\n    int u_bracket = 0;\n    int v_bracket ="], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    for (long i = 0; i < l.size(); i++) {\n        if (l[i] > l[i + 1]) {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> common(l1.size(), 0);\n    for (int i = 0; i < l1.size(); i++) {\n        common[l1[i]] += l2[i];\n    }\n    return common;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long max_prime_factor = 1;\n    long max_prime_factor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max_prime_factor_divisor_divisor = 1;\n    long max"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  long sum = 0;\n  for (long i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    int n = brackets.size();\n    if (n == 0) {\n        return true;\n    }\n    if (n == 1) {\n        return brackets[0] == '(';\n    }\n    if (n == 2) {\n        return brackets[0] == '(';\n    }\n    if (n == 3) {\n        return brackets[0] == ')';\n    }\n    if (n == 4) {\n        return brackets[0] == '(';\n    }\n    if (n == 5) {\n        return brackets[0] == ')';\n    }\n    if (n == 6) {\n        return brackets[0] == '(';\n    }\n    if (n == 7) {\n        return brackets[0] == '(';\n    }\n    if (n == 8) {\n        return brackets[0] == '(';\n    }\n    if (n == 9) {\n        return brackets[0] == '(';\n    }\n    if (n == 10) {\n        return brackets[0] == '(';\n    }\n    if (n == 11) {\n        return brackets[0] == '(';\n    }\n    if (n == 12) {\n        return brackets[0] == '(';\n    }\n    if (n == 13) {\n        return brackets[0] == '(';\n    }\n    if (n == 14) {\n        return brackets[0] == '(';\n    }\n    if (n == 15) {\n        return brackets[0] == '(';\n    }\n    if (n == 16) {\n        return brackets[0] == '(';\n    }\n    if (n == 17) {\n        return brackets[0] == '(';\n    }\n    if (n == 18) {\n        return brackets[0] == '(';\n    }\n    if (n == 19) {\n        return brackets[0] == '(';\n    }\n    if (n == 20) {\n        return brackets[0] == '(';\n    }\n    if (n == 21) {\n        return brackets[0] == '(';\n    }\n    if (n == 22) {\n        return brackets[0] == '(';\n    }\n    if (n == 23) {\n        return brackets[0] == '(';\n    }\n    if (n == 24) {\n        return brackets[0] == '(';\n    }\n    if (n == 25) {\n        return brackets[0] == '(';\n    }\n    if (n == 26) {\n        return brackets[0] == '(';\n    }\n    if (n == 27) {\n        return brackets[0] == '(';\n    }\n    if (n == 28) {\n        return brackets[0] == '(';\n    }\n    if (n == 29) {\n        return brackets[0] == '(';\n    }\n    if (n == 30) {\n        return brackets[0] == '(';\n    }\n    if (n == 31) {\n        return brackets[0] == '(';\n    }\n    if (n == 32) {\n        return brackets[0] == '(';\n    }\n    if (n == 33) {\n        return brackets[0] == '(';\n    }\n    if (n == 34) {\n        return brackets[0] == '(';\n    }\n    if (n == 35) {\n        return brackets[0] == '(';\n    }\n    if (n == 36) {\n        return brackets[0] == '(';\n    }\n    if (n == 37) {\n        return brackets[0] == '(';\n    }\n    if (n == 38) {\n        return brackets[0] == '(';\n    }\n    if (n == 39) {\n        return brackets[0] == '(';\n    }\n    if (n == 40) {\n        return brackets[0] == '(';\n    }\n    if"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    long dx = xs[0];\n    long dy = xs[1];\n    long dz = xs[2];\n    long dz2 = xs[3];\n    long dz3 = xs[4];\n    long dz4 = xs[5];\n    long dz5 = xs[6];\n    long dz6 = xs[7];\n    long dz7 = xs[8];\n    long dz8 = xs[9];\n    long dz9 = xs[10];\n    long dz10 = xs[11];\n    long dz11 = xs[12];\n    long dz12 = xs[13];\n    long dz13 = xs[14];\n    long dz14 = xs[15];\n    long dz15 = xs[16];\n    long dz16 = xs[17];\n    long dz17 = xs[18];\n    long dz18 = xs[19];\n    long dz19 = xs[20];\n    long dz20 = xs[21];\n    long dz21 = xs[22];\n    long dz22 = xs[23];\n    long dz23 = xs[24];\n    long dz24 = xs[25];\n    long dz25 = xs[26];\n    long dz26 = xs[27];\n    long dz27 = xs[28];\n    long dz28 = xs[29];\n    long dz29 = xs[30];\n    long dz30 = xs[31];\n    long dz31 = xs[32];\n    long dz32 = xs[33];\n    long dz33 = xs[34];\n    long dz34 = xs[35];\n    long dz35 = xs[36];\n    long dz36 = xs[37];\n    long dz37 = xs[38];\n    long dz38 = xs[39];\n    long dz39 = xs[40];\n    long dz40 = xs[41];\n    long dz41 = xs[42];\n    long dz42 = xs[43];\n    long dz43 = xs[44];\n    long dz44 = xs[45];\n    long dz45 = xs[46];\n    long dz46 = xs[47];\n    long dz47 = xs[48];\n    long dz48 = xs[49];\n    long dz49 = xs[50];\n    long dz50 = xs[51];\n    long dz51 = xs[52];\n    long dz52 = xs[53];\n    long dz53 = xs[54];\n    long dz54 = xs[55];\n    long dz55 = xs[56];\n    long dz56 = xs[57];\n    long dz57 = xs[58];\n    long dz58 = xs[59];\n    long dz59 = xs[60];\n    long dz60 = xs[61];\n    long dz61 = xs[62];\n    long dz62 = xs[63];\n    long dz63 = xs[64];\n    long dz64 = xs[65];\n    long dz65 = xs[66];\n    long dz66 = xs[67];\n    long dz67 = xs[68];\n    long dz68 = xs[69];\n    long dz69 = xs"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    long ret = 0;\n    for (long i = 0; i < n; i++) {\n        ret += fibfib(i);\n    }\n    return ret;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    std::vector<std::string> vowels;\n    for (auto c : s) {\n        if (c >= 'a' && c <= 'z') {\n            vowels.push_back(c);\n        }\n    }\n    return vowels.size();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string result;\n    std::stringstream ss;\n    ss << x;\n    ss >> shift;\n    for (long i = 0; i < shift; i++) {\n        ss >> result;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    int n = s.size();\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < n) {\n        if (s[i] == 'A') {\n            sum += (i + 1);\n        } else if (s[i] == 'B') {\n            sum += (i + 2);\n        } else if (s[i] == 'C') {\n            sum += (i + 3);\n        } else if (s[i] == 'D') {\n            sum += (i + 4);\n        } else if (s[i] == 'E') {\n            sum += (i + 5);\n        } else if (s[i] == 'F') {\n            sum += (i + 6);\n        } else {\n            sum += (i + 7);\n        }\n        i++;\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    std::string s_str = s;\n    std::string s_str_reversed = s_str.substr(s_str.find_last_of(\"0\") + 1);\n    std::string s_str_reversed = s_str.substr(s_str.find_last_of(\"0\") + 1);\n    long n_int = s_str_reversed.length();\n    long n_str = s_str_reversed.length();\n    long n_str_reversed = n_str - n_int;\n    long n_str_reversed_reversed = n_str_reversed * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> res(arr.size());\n    for (int i = 0; i < arr.size(); i++) {\n        res[i] = arr[i];\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n\tlong max_freq = 0;\n\tfor (auto i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > max_freq) {\n\t\t\tmax_freq = lst[i];\n\t\t}\n\t}\n\treturn max_freq;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] < lst[i + 1]) {\n            result.push_back(lst[i]);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    return (a + b + c) / 3.0;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    long max_weight = 0;\n    for (long i = 0; i < q.size(); i++) {\n        if (sum > max_weight) {\n            max_weight = sum;\n            q[i] = q.size() - 1;\n        }\n    }\n    return q[q.size() - 1] == q.size() - 1;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long m = (n + 1) / 2;\n    long k = 0;\n    long temp = arr[0];\n    for (int i = 0; i < n; i++) {\n        temp = temp % m;\n        if (temp != 0) {\n            k++;\n        }\n    }\n    return k;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  std::vector<std::string> result;\n  std::string temp;\n  for (int i = 0; i < lst1.size(); i++) {\n    temp = lst1[i];\n    if (temp.length() < lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n    if (temp.length() > lst1.length()) {\n      temp = lst1[i];\n    }\n    if (temp.length() > lst2.length()) {\n      temp = lst2[i];\n    }\n   "], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    long power = 1;\n    long power_mod = 1;\n    long power_mod_pow = 1;\n    long power_mod_pow_pow = 1;\n    long power_mod_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    long power_mod_pow_pow_pow_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long n = a;\n    long m = n;\n    long q = (n - m) / 2;\n    long r = (n - m) % 2;\n    long s = (n - m) / 2;\n    long t = (n - m) % 2;\n    long u = (n - m) / 2;\n    long v = (n - m) % 2;\n    long w = (n - m) / 2;\n    long x = (n - m) / 2;\n    long y = (n - m) % 2;\n    long z = (n - m) / 2;\n    long qw = (n - m) / 2;\n    long qh = (n - m) % 2;\n    long qwh = (n - m) % 2;\n    long qhw = (n - m) % 2;\n    long qhwh = (n - m) % 2;\n    long qhwh = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) / 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) % 2;\n    long qhw = (n - m) / 2;\n    long qwh = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n - m) % 2;\n    long qwh = (n - m) / 2;\n    long qhw = (n"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long result = 0;\n    for (char c : num) {\n        if (c >= '0' && c <= '9') {\n            result += (c - '0');\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary_string;\n    std::stringstream binary_stream;\n    binary_stream << decimal;\n    std::string binary_str = binary_stream.str();\n    std::string binary_num = binary_str.substr(0, binary_str.length() - 1);\n    std::string binary_num_str = binary_str.substr(binary_str.length() - 1);\n    std::string binary_num_str_str = binary_str.substr(binary_str.length() - 1);\n    binary_num_str_str += binary_num;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary_num_str;\n    binary_num_str_str += binary"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    int len = s.length();\n    if (len < 3) {\n        return false;\n    }\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (s[i] == s[j]) {\n            i++;\n            j--;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> grades_vector;\n  for (int i = 0; i < grades.size(); i++) {\n    if (grades[i] >= grades[i + 1]) {\n      grades_vector.push_back(grades[i]);\n    }\n  }\n  return grades_vector;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length % 2 == 0) {\n        return false;\n    }\n    for (int i = 0; i < length; i++) {\n        if (string[i] == '1') {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long count = 0;\n    for (long i = 1; i <= n; i++) {\n        if (i % 10 == 0) {\n            count++;\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string ans;\n    std::vector<long> digits;\n    long n = N;\n    long k = 0;\n    long sum = 0;\n    while (k < n) {\n        long i = k % 10;\n        long j = (k - i) % 10;\n        long kk = (k - i) / 10;\n        long kk1 = (k - i) % 10;\n        long kk2 = (k - i) / 10;\n        long kk3 = (k - i) % 10;\n        long kk4 = (k - i) / 10;\n        long kk5 = (k - i) % 10;\n        long kk6 = (k - i) / 10;\n        long kk7 = (k - i) % 10;\n        long kk8 = (k - i) / 10;\n        long kk9 = (k - i) % 10;\n        long kk10 = (k - i) / 10;\n        long kk11 = (k - i) % 10;\n        long kk12 = (k - i) / 10;\n        long kk13 = (k - i) % 10;\n        long kk14 = (k - i) / 10;\n        long kk15 = (k - i) % 10;\n        long kk16 = (k - i) / 10;\n        long kk17 = (k - i) % 10;\n        long kk18 = (k - i) / 10;\n        long kk19 = (k - i) % 10;\n        long kk20 = (k - i) / 10;\n        long kk21 = (k - i) % 10;\n        long kk22 = (k - i) / 10;\n        long kk23 = (k - i) % 10;\n        long kk24 = (k - i) / 10;\n        long kk25 = (k - i) % 10;\n        long kk26 = (k - i) / 10;\n        long kk27 = (k - i) % 10;\n        long kk28 = (k - i) / 10;\n        long kk29 = (k - i) % 10;\n        long kk30 = (k - i) / 10;\n        long kk31 = (k - i) % 10;\n        long kk32 = (k - i) / 10;\n        long kk33 = (k - i) % 10;\n        long kk34 = (k - i) / 10;\n        long kk35 = (k - i) % 10;\n        long kk36 = (k - i) / 10;\n        long kk37 = (k - i) % 10;\n        long kk38 = (k - i) / 10;\n        long kk39 = (k - i) % 10;\n        long kk40 = (k - i) / 10;\n        long kk41 = (k - i) % 10;\n        long kk42 = (k - i) / 10;\n        long kk43 = (k - i) % 10;\n        long kk44 = (k - i) / 10;\n        long kk45 = (k - i) % 10;\n        long kk46 = (k - i) / 10;\n        long kk47 = (k - i) % 10;\n        long kk48 = (k - i) / 10;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long res = 0;\n    for (auto i = 0; i < lst.size(); i++) {\n        if (lst[i] % 2 == 0) {\n            res += lst[i];\n        }\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::string tmp;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == ' ') {\n            s[i] = '0';\n        }\n        else if (s[i] == ' ') {\n            s[i] = '1';\n        }\n        else if (s[i] == ' ') {\n            s[i] = '2';\n        }\n        else if (s[i] == '3') {\n            s[i] = '4';\n        }\n        else if (s[i] == '5') {\n            s[i] = '6';\n        }\n        else if (s[i] == '7') {\n            s[i] = '8';\n        }\n        else if (s[i] == '9') {\n            s[i] = '0';\n        }\n    }\n    return s;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> ret;\n  for (auto& row : lst) {\n    for (auto& col : row) {\n      if (col == x) {\n        ret.push_back(std::make_tuple(col, row));\n      }\n    }\n  }\n  return ret;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> sorted_array(array.size());\n    for (int i = 0; i < array.size(); i++) {\n        if (array[i] > array[i + 1]) {\n            sorted_array[i] = array[i];\n        }\n    }\n    return sorted_array;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted;\n    for (int i = 0; i < s.size(); i++) {\n        if (i == 0) {\n            encrypted += s[i];\n        } else {\n            encrypted += s[i] + \" \";\n        }\n    }\n    return encrypted;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    long min = lst[0];\n    for (long i = 1; i < lst.size(); i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        }\n    }\n    return min;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (word.size() > 0) {\n            if (word.size() > 1) {\n                if (word.size() > 2) {\n                    if (word.size() > 3) {\n                        if (word.size() > 4) {\n                            if (word.size() > 5) {\n                                if (word.size() > 6) {\n                                    if (word.size() > 7) {\n                                        if (word.size() > 8) {\n                                            if (word.size() > 9) {\n                                                if (word.size() > 10) {\n                                                    if (word.size() > 11) {\n                                                        if (word.size() > 12) {\n                                  //  std::cout << word << std::endl;\n                                }\n                                }\n                                else {\n                                    if (word.size() > 13) {\n                                        if (word.size() > 14) {\n                                            if (word.size() > 15) {\n                                                if (word.size() > 16) {\n                                                    if (word.size() > 17) {\n                                                        if (word.size() > 18) {\n                                  //  std::cout << word << std::endl;\n                                  }\n                                }\n                                }\n                                else {\n                                    if (word.size() > 19) {\n                                        if (word.size() > 20) {\n                                            if (word.size() > 21) {\n                                                if (word.size() > 22) {\n                                                    if (word.size() > 23) {\n                                                        if (word.size() > 24) {\n                                  //  std::cout << word << std::endl;\n                                  }\n                                }\n                                }\n                                else {\n                                    if (word.size() > 25) {\n                                        if (word.size() > 26) {\n                                            if (word.size() > 27) {\n                                                if (word.size() > 28) {\n                                                    if (word.size() > 29) {\n                                                        if (word.size() > 30) {\n                                  //  std::cout << word << std::endl;\n                                  }\n                                }\n                                }\n                                else {\n                                    if (word.size() > 31) {\n                                        if (word.size() > 32) {\n                                            if (word.size() > 33) {\n                                                if (word.size() > 34) {\n                                                    if (word.size() > 35) {\n                                                        if (word.size() > 36) {\n                                  //  std::cout << word << std::endl;\n                                  }\n                                }\n                                }\n                                else {\n                                    if (word.size() > 37) {\n                                        if (word.size() > 38) {\n                                            if (word.size() > 39) {\n                                                if (word.size() > 40) {\n                                                    if (word.size() > 41) {\n                                                        if (word.size() > 42) {\n                                  //  std::cout << word << std::endl;\n                                  }\n                                }\n                                }\n                                else {\n                                    if (word.size() > 43) {\n                                        if (word.size() > 44) {\n                                            if (word.size() > 45) {\n                                                if (word.size() > 46) {\n                                                    if (word.size() > 47) {\n                                                        if (word.size() > 48) {\n                                  //  std::cout << word << std::endl;\n                                  }\n                                }\n                                }\n                                else {\n                                    if (word.size() > 49) {\n                                        if (word.size() > 50) {\n                                            if (word.size() > 51) {\n                                                if (word.size() > 52) {\n                                                    if (word.size() > 53)"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    return (x + y + z == x + y + z);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string encoded = message;\n    std::string::size_type pos = 0;\n    while (pos < encoded.length()) {\n        if (encoded[pos] == ' ') {\n            encoded[pos] = 'a';\n            pos++;\n        } else {\n            if (pos == encoded.length() - 1) {\n                pos = 0;\n            }\n            encoded[pos] = 'a';\n            pos++;\n        }\n    }\n    return encoded;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long sum = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        sum += (lst[i] - (lst[i] % 10));\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  std::string key;\n  std::string value;\n  for (auto it = dict.begin(); it != dict.end(); ++it) {\n    key = it->first;\n    value = it->second;\n    if (key.compare(key) == 0) {\n      return true;\n    }\n  }\n  return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n\tstd::vector<long> result;\n\tlong i = 0;\n\twhile (i < n) {\n\t\tif (!(i % 2)) {\n\t\t\tresult.push_back(i);\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long res = 1;\n    for (long i = a; i <= b; i += 10) {\n        res *= i;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    std::vector<int> v(s.size());\n    for (int i = 0; i < s.size(); i++) {\n        v[i] = 0;\n    }\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            v[s[i] - 'a']++;\n        }\n    }\n    for (int i = 0; i < s.size(); i++) {\n        if (v[i] > 0) {\n            return i;\n        }\n    }\n    return -1;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  long closest_integer = 0;\n  int num_digits = value.size() / 10;\n  for (int i = 0; i < num_digits; i++) {\n    int digit = value.at(i) - '0';\n    if (digit < 0) {\n      continue;\n    }\n    if (digit > 0) {\n      if (i == 0) {\n        closest_integer = value.at(i);\n      }\n      else {\n        int temp = value.at(i - 1) - digit;\n        if (temp > closest_integer) {\n          closest_integer = temp;\n        }\n      }\n    }\n  }\n  return closest_integer;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n\tstd::vector<long> result;\n\tfor (long i = 0; i < n; ++i) {\n\t\tlong j = i + 1;\n\t\tlong k = i + 2;\n\t\tlong m = i + 3;\n\t\tlong n = i + 4;\n\t\tlong p = i + 5;\n\t\tlong q = i + 6;\n\t\tlong r = i + 7;\n\t\tlong s = i + 8;\n\t\tlong t = i + 9;\n\t\tlong u = i + 10;\n\t\tlong v = i + 11;\n\t\tlong w = i + 12;\n\t\tlong x = i + 13;\n\t\tlong y = i + 14;\n\t\tlong z = i + 15;\n\t\tlong w_i = (i + 1) % n;\n\t\tlong w_j = (i + 2) % n;\n\t\tlong w_k = (i + 3) % n;\n\t\tlong w_l = (i + 4) % n;\n\t\tlong w_m = (i + 5) % n;\n\t\tlong w_n = (i + 6) % n;\n\t\tlong w_o = (i + 7) % n;\n\t\tlong w_p = (i + 8) % n;\n\t\tlong w_q = (i + 9) % n;\n\t\tlong w_r = (i + 10) % n;\n\t\tlong w_s = (i + 11) % n;\n\t\tlong w_t = (i + 12) % n;\n\t\tlong w_u = (i + 13) % n;\n\t\tlong w_v = (i + 14) % n;\n\t\tlong w_w = (i + 15) % n;\n\t\tlong w_x = (i + 16) % n;\n\t\tlong w_y = (i + 17) % n;\n\t\tlong w_z = (i + 18) % n;\n\t\tlong w_t = (i + 19) % n;\n\t\tlong w_u = (i + 20) % n;\n\t\tlong w_v = (i + 21) % n;\n\t\tlong w_w = (i + 22) % n;\n\t\tlong w_x = (i + 23) % n;\n\t\tlong w_y = (i + 24) % n;\n\t\tlong w_z = (i + 25) % n;\n\t\tlong w_t = (i + 26) % n;\n\t\tlong w_u = (i + 27) % n;\n\t\tlong w_v = (i + 28) % n;\n\t\tlong w_w = (i + 29) % n;\n\t\tlong w_x = (i + 30) % n;\n\t\tlong w_y = (i + 31) % n;\n\t\tlong w_z = (i + 32) % n;\n\t\tlong w_t = (i + 33) % n;\n\t\tlong w_u = (i + 34) % n;\n\t\tlong w_v = (i + 35) % n;\n\t\tlong w_w = (i + 36) % n;\n\t\tlong w_x = (i + 37) % n;\n\t\tlong w_y = (i + 38) % n;\n\t\tlong w_z = (i + 39) % n;\n\t\tlong w_t ="], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string temp;\n    std::string temp2;\n    std::string temp3;\n    std::string temp4;\n    std::string temp5;\n    std::string temp6;\n    std::string temp7;\n    std::string temp8;\n    std::string temp9;\n    std::string temp10;\n    std::string temp11;\n    std::string temp12;\n    std::string temp13;\n    std::string temp14;\n    std::string temp15;\n    std::string temp16;\n    std::string temp17;\n    std::string temp18;\n    std::string temp19;\n    std::string temp20;\n    std::string temp21;\n    std::string temp22;\n    std::string temp23;\n    std::string temp24;\n    std::string temp25;\n    std::string temp26;\n    std::string temp27;\n    std::string temp28;\n    std::string temp29;\n    std::string temp30;\n    std::string temp31;\n    std::string temp32;\n    std::string temp33;\n    std::string temp34;\n    std::string temp35;\n    std::string temp36;\n    std::string temp37;\n    std::string temp38;\n    std::string temp39;\n    std::string temp40;\n    std::string temp41;\n    std::string temp42;\n    std::string temp43;\n    std::string temp44;\n    std::string temp45;\n    std::string temp46;\n    std::string temp47;\n    std::string temp48;\n    std::string temp49;\n    std::string temp50;\n    std::string temp51;\n    std::string temp52;\n    std::string temp53;\n    std::string temp54;\n    std::string temp55;\n    std::string temp56;\n    std::string temp57;\n    std::string temp58;\n    std::string temp59;\n    std::string temp60;\n    std::string temp61;\n    std::string temp62;\n    std::string temp63;\n    std::string temp64;\n    std::string temp65;\n    std::string temp66;\n    std::string temp67;\n    std::string temp68;\n    std::string temp69;\n    std::string temp70;\n    std::string temp71;\n    std::string temp72;\n    std::string temp73;\n    std::string temp74;\n    std::string temp75;\n    std::string temp76;\n    std::string temp77;\n    std::string temp78;\n    std::string temp79;\n    std::string temp80;\n    std::string temp81;\n    std::string temp82;\n    std::string temp83;\n    std::string temp84;\n    std::string temp85;\n    std::string temp86;\n    std::string temp87;\n    std::string temp88;\n    std::string temp89;\n    std::string temp90;\n    std::string temp91;\n    std::string temp92;\n    std::string temp93;\n    std::string temp94;\n    std::string temp95;\n    std::string temp96;\n    std::string temp97;\n    std::string temp98;\n    std::string temp99;\n    std::string temp100;\n    std::string temp1"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  long n = x;\n  long m = y;\n  long res = 0;\n  while (n > 0) {\n    long temp = n % 2;\n    if (temp == 0) {\n      res += (long)pow(2, m - 1) - 1;\n    }\n    n = n / 2;\n    m = m - 1;\n  }\n  return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    long sum = 0;\n    long sum_mod = 0;\n    long sum_div = 0;\n    long sum_div_mod = 0;\n    long sum_div_mod_mod = 0;\n    long sum_div_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod_mod = 0;\n    long sum_div_mod_mod_mod_mod_mod_mod_mod_mod_mod"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> ans(x.size());\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            ans[i] = x[i];\n        }\n    }\n    return ans;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> result;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < 10) {\n            result.push_back(arr[i]);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    long i = 0;\n    long sum = 0;\n    while (i < n) {\n        sum += (long)i;\n        i++;\n    }\n    result.push_back(sum);\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    std::vector<long> palindromes;\n    for (long i = 1; i <= n; i++) {\n        long odd = i % 2;\n        long even = i % 2;\n        if (odd == 0) {\n            palindromes.push_back(i);\n        } else {\n            palindromes.push_back(i);\n        }\n    }\n    std::sort(palindromes.begin(), palindromes.end());\n    return std::make_tuple(palindromes[0], palindromes[palindromes.size() - 1]);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            count += (long)arr[i] - (long)1000000000;\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    long n = arr.size();\n    long i = 0;\n    long j = n - 1;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n1 = arr[i];\n    long n2 = arr[j];\n    long n3 = arr[k];\n    long n4 = arr[l];\n    long n5 = arr[m];\n    long n6 = arr[n1];\n    long n7 = arr[n2];\n    long n8 = arr[n3];\n    long n9 = arr[n4];\n    long n10 = arr[n5];\n    long n11 = arr[n6];\n    long n12 = arr[n7];\n    long n13 = arr[n8];\n    long n14 = arr[n9];\n    long n15 = arr[n10];\n    long n16 = arr[n11];\n    long n17 = arr[n12];\n    long n18 = arr[n13];\n    long n19 = arr[n14];\n    long n20 = arr[n15];\n    long n21 = arr[n16];\n    long n22 = arr[n17];\n    long n23 = arr[n18];\n    long n24 = arr[n19];\n    long n25 = arr[n20];\n    long n26 = arr[n21];\n    long n27 = arr[n22];\n    long n28 = arr[n23];\n    long n29 = arr[n24];\n    long n30 = arr[n25];\n    long n31 = arr[n26];\n    long n32 = arr[n27];\n    long n33 = arr[n28];\n    long n34 = arr[n29];\n    long n35 = arr[n30];\n    long n36 = arr[n31];\n    long n37 = arr[n32];\n    long n38 = arr[n33];\n    long n39 = arr[n34];\n    long n40 = arr[n35];\n    long n41 = arr[n36];\n    long n42 = arr[n37];\n    long n43 = arr[n38];\n    long n44 = arr[n39];\n    long n45 = arr[n40];\n    long n46 = arr[n41];\n    long n47 = arr[n42];\n    long n48 = arr[n43];\n    long n49 = arr[n44];\n    long n50 = arr[n45];\n    long n51 = arr[n46];\n    long n52 = arr[n47];\n   "], ["#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    std::string res;\n    for (int i = 0; i < lst1.size(); i++) {\n        for (int j = 0; j < lst2.size(); j++) {\n            if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0) {\n                res += lst1[i];\n                lst2[j] = lst2[j] % 2;\n            }\n        }\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::stringstream ss(test);\n    std::string tmp;\n    std::string tmp2;\n    std::string tmp3;\n    std::string tmp4;\n    std::string tmp5;\n    std::string tmp6;\n    std::string tmp7;\n    std::string tmp8;\n    std::string tmp9;\n    std::string tmp10;\n    std::string tmp11;\n    std::string tmp12;\n    std::string tmp13;\n    std::string tmp14;\n    std::string tmp15;\n    std::string tmp16;\n    std::string tmp17;\n    std::string tmp18;\n    std::string tmp19;\n    std::string tmp20;\n    std::string tmp21;\n    std::string tmp22;\n    std::string tmp23;\n    std::string tmp24;\n    std::string tmp25;\n    std::string tmp26;\n    std::string tmp27;\n    std::string tmp28;\n    std::string tmp29;\n    std::string tmp30;\n    std::string tmp31;\n    std::string tmp32;\n    std::string tmp33;\n    std::string tmp34;\n    std::string tmp35;\n    std::string tmp36;\n    std::string tmp37;\n    std::string tmp38;\n    std::string tmp39;\n    std::string tmp40;\n    std::string tmp41;\n    std::string tmp42;\n    std::string tmp43;\n    std::string tmp44;\n    std::string tmp45;\n    std::string tmp46;\n    std::string tmp47;\n    std::string tmp48;\n    std::string tmp49;\n    std::string tmp50;\n    std::string tmp51;\n    std::string tmp52;\n    std::string tmp53;\n    std::string tmp54;\n    std::string tmp55;\n    std::string tmp56;\n    std::string tmp57;\n    std::string tmp58;\n    std::string tmp59;\n    std::string tmp60;\n    std::string tmp61;\n    std::string tmp62;\n    std::string tmp63;\n    std::string tmp64;\n    std::string tmp65;\n    std::string tmp66;\n    std::string tmp67;\n    std::string tmp68;\n    std::string tmp69;\n    std::string tmp70;\n    std::string tmp71;\n    std::string tmp72;\n    std::string tmp73;\n    std::string tmp74;\n    std::string tmp75;\n    std::string tmp76;\n    std::string tmp77;\n    std::string tmp78;\n    std::string tmp79;\n    std::string tmp80;\n    std::string tmp81;\n    std::string tmp82;\n    std::string tmp83;\n    std::string tmp84;\n    std::string tmp85;\n    std::string tmp86;\n    std::string tmp87;\n    std::string tmp88;\n    std::string tmp89;\n    std::string tmp90;\n    std::string tmp91;\n    std::string tmp92;\n    std::string tmp93;\n    std::string tmp94;\n    std::string tmp95;\n    std::string"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string s_copy = s;\n    std::string c_copy = c;\n    std::string s_copy = s;\n    std::string c_copy = c;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_copy;\n    std::string c_copy_copy = c_copy;\n    std::string s_copy_copy = s_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n\tstd::vector<std::string> output;\n\tfor (auto str : lst) {\n\t\tif (str.size() % 2 != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tint odd_count = 0;\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\tif (str[i] == '1') {\n\t\t\t\todd_count++;\n\t\t\t}\n\t\t}\n\t\toutput.push_back(str);\n\t}\n\treturn output;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long sum = 0;\n    for (long i = 0; i < nums.size(); i++) {\n        sum += nums[i];\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = capacity - 1;\n    long max_fill = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                max_fill += 1;\n            }\n        }\n    }\n    return max_fill;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::vector<long> sorted_arr(arr.size());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == 1) {\n            sorted_arr[i] = arr[i];\n        }\n    }\n    return sorted_arr;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> words;\n    std::string s_lower = s.toLower();\n    std::string s_upper = s.toUpper();\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_of(' '));\n    std::string s_lower_c = s_lower.substr(0, s_lower.find_first_of(' '));\n    std::string s_upper_c = s_upper.substr(0, s_upper.find_first_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    std::string vowels_to_consonants = vowels.join(\",\");\n    std::string consonants_to_vowels = consonants.join(\",\");\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_consonants_to_vowels = vowels_to_consonants + consonants;\n    std::string vowels_to_conson"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string result = \"\";\n    for (auto s : lst) {\n        if (s == \"(\") {\n            result += \"(\";\n        } else if (s == \")\") {\n            result += \")\" + s;\n        } else {\n            result += s;\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> max_arr(arr.size());\n    for (int i = 0; i < max_arr.size(); i++) {\n        max_arr[i] = arr[i];\n    }\n    std::sort(max_arr.begin(), max_arr.end());\n    std::reverse(max_arr.begin(), max_arr.end());\n    std::vector<long> max_arr_sorted(max_arr.begin(), max_arr.end());\n    for (int i = 0; i < max_arr_sorted.size(); i++) {\n        max_arr_sorted[i] = max_arr_sorted[i] + max_arr[i];\n    }\n    return max_arr_sorted;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (auto i : lst) {\n        sum += i;\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        sum += arr[i];\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> v;\n    for (long i = 0; i < n; i++) {\n        long x = i % 2;\n        v.push_back(x);\n    }\n    return v;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    std::string month_str = date.substr(0, 2);\n    std::string day_str = date.substr(3, 2);\n    std::string year_str = date.substr(6, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_str.substr(0, 2);\n    std::string year_str = year_str.substr(0, 2);\n    std::string month_str = month_str.substr(0, 2);\n    std::string day_str = day_"], ["#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> words;\n    std::string temp;\n    std::string::size_type pos = 0;\n    while (pos < txt.length()) {\n        if (txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos] == ',' || txt[pos]"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    if (lst.size() < 1) {\n        return false;\n    }\n    std::sort(lst.begin(), lst.end());\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start = std::get<0>(interval1);\n    long end = std::get<1>(interval1);\n    long length = std::get<2>(interval1);\n    long end_index = std::get<3>(interval1);\n    long start_index = std::get<4>(interval1);\n    long end_index = std::get<5>(interval1);\n    long start_index = std::get<6>(interval1);\n    long end_index = std::get<7>(interval1);\n    long end_index = std::get<8>(interval1);\n    long start_index = std::get<9>(interval1);\n    long end_index = std::get<10>(interval1);\n    long end_index = std::get<11>(interval1);\n    long start_index = std::get<12>(interval1);\n    long end_index = std::get<13>(interval1);\n    long end_index = std::get<14>(interval1);\n    long start_index = std::get<15>(interval1);\n    long end_index = std::get<16>(interval1);\n    long end_index = std::get<17>(interval1);\n    long start_index = std::get<18>(interval1);\n    long end_index = std::get<19>(interval1);\n    long end_index = std::get<20>(interval1);\n    long start_index = std::get<21>(interval1);\n    long end_index = std::get<22>(interval1);\n    long end_index = std::get<23>(interval1);\n    long start_index = std::get<24>(interval1);\n    long end_index = std::get<25>(interval1);\n    long end_index = std::get<26>(interval1);\n    long start_index = std::get<27>(interval1);\n    long end_index = std::get<28>(interval1);\n    long end_index = std::get<29>(interval1);\n    long start_index = std::get<30>(interval1);\n    long end_index = std::get<31>(interval1);\n    long end_index = std::get<32>(interval1);\n    long start_index = std::get<33>(interval1);\n    long end_index = std::get<34>(interval1);\n    long end_index = std::get<35>(interval1);\n    long start_index = std::get<36>(interval1);\n    long end_index = std::get<37>(interval1);\n    long end_index = std::get<38>(interval1);\n    long start_index = std::get<39>(interval1);\n    long end_index = std::get<40>(interval"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        sum += arr[i] * (arr[i] - 1);\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    std::vector<long> lst_A(grid.size(), 0);\n    std::vector<long> lst_B(grid.size(), 0);\n    std::vector<long> lst_C(grid.size(), 0);\n    std::vector<long> lst_D(grid.size(), 0);\n    std::vector<long> lst_E(grid.size(), 0);\n    std::vector<long> lst_F(grid.size(), 0);\n    std::vector<long> lst_G(grid.size(), 0);\n    std::vector<long> lst_H(grid.size(), 0);\n    std::vector<long> lst_I(grid.size(), 0);\n    std::vector<long> lst_J(grid.size(), 0);\n    std::vector<long> lst_K(grid.size(), 0);\n    std::vector<long> lst_L(grid.size(), 0);\n    std::vector<long> lst_M(grid.size(), 0);\n    std::vector<long> lst_N(grid.size(), 0);\n    std::vector<long> lst_O(grid.size(), 0);\n    std::vector<long> lst_P(grid.size(), 0);\n    std::vector<long> lst_Q(grid.size(), 0);\n    std::vector<long> lst_R(grid.size(), 0);\n    std::vector<long> lst_S(grid.size(), 0);\n    std::vector<long> lst_T(grid.size(), 0);\n    std::vector<long> lst_U(grid.size(), 0);\n    std::vector<long> lst_V(grid.size(), 0);\n   "], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  for (long i = 0; i < n; i++) {\n    long tmp = (long)i;\n    if (tmp % 2 == 0) {\n      result.push_back(tmp);\n    }\n  }\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long sum = 0;\n  for (long i = 0; i < n; i++) {\n    sum += (long)pow(2, i);\n  }\n  return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::vector<std::string> substring;\n    std::string substring_to_check;\n    std::string substring_to_replace;\n    std::string substring_to_replace_to_check;\n    std::string substring_to_replace_to_check;\n    std::string substring_to_replace_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n    std::string substring_to_replace_to_check_to_check;\n   "], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto& x : lst) {\n        sum += x * x;\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    std::string last_char = txt.back();\n    if (last_char == 'a' || last_char == 'e' || last_char == 'i' || last_char == 'o' || last_char == 'u') {\n        return true;\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long max_index = -1;\n    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        if (it->second > max_index) {\n            max_index = it->second;\n        }\n    }\n    return max_index;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::vector<long> v;\n  for (auto& x : lst) {\n    v.push_back(x);\n  }\n  std::sort(v.begin(), v.end());\n  std::vector<long> res(v.size());\n  for (auto& x : v) {\n    res[x] = x;\n  }\n  return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    return a.f0 + b.f0;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n < 0) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0; i < n; i++) {\n        sum += n % 2;\n    }\n    if (sum % 2 == 0) {\n        return true;\n    }\n    else {\n        return false;\n    }"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result = text;\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == ' ' || text[i] == '\\t') {\n            text[i] = ' ';\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::string file_name_str = file_name;\n    std::string file_name_str_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus_dots = file_name_str.substr(0, file_name_str.size() - 2);\n    std::string file_name_str_minus_dot_minus"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        sum += (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] * (lst[i] *"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::string word;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n            word = sentence.substr(0, i);\n            word.push_back(sentence[i]);\n        }\n        else {\n            word.push_back(sentence[i]);\n        }\n    }\n    if (word.length() > 0) {\n        for (int i = 0; i < word.length(); i++) {\n            if (word[i] == ' ') {\n                word.push_back(word[i]);\n            }\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int numerator = std::stoi(x);\n    int denominator = std::stoi(n);\n    if (numerator >= denominator) {\n        return false;\n    }\n    if (numerator < 0) {\n        return false;\n    }\n    if (numerator > 0) {\n        return true;\n    }\n    if (numerator < 0) {\n        return false;\n    }\n    if (numerator > denominator) {\n        return false;\n    }\n    if (numerator < denominator) {\n        return true;\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<long> result;\n    for (long i = 0; i < nums.size(); i++) {\n        if (nums[i] > 0) {\n            result.push_back(nums[i]);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long max_num = 0;\n    for (long i = 0; i < nums.size(); i++) {\n        long num = nums[i];\n        if (num > max_num) {\n            max_num = num;\n        }\n    }\n    return max_num;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long ww = 0;\n    long www = 0;\n    long wwww = 0;\n    long wwwww = 0;\n    long wwwwww = 0;\n    long wwwwwww = 0;\n    long wwwwwwww = 0;\n    long wwwwwwwww = 0;\n    long wwwwwwwwww = 0;\n    long wwwwwwwwwww = 0;\n    long wwwwwwwwwwww = 0;\n    long wwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0;\n    long wwwwwwwwwwwwww = 0"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n\tstd::vector<std::string> planets;\n\tstd::string planet1_name = planet1;\n\tstd::string planet2_name = planet2;\n\tstd::string planet1_position = planet1_name;\n\tstd::string planet2_position = planet2_name;\n\tstd::string planet1_orbit = planet1_position;\n\tstd::string planet2_orbit = planet2_position;\n\tstd::string planet1_orbit_x = planet1_orbit;\n\tstd::string planet2_orbit_x = planet2_orbit;\n\tstd::string planet1_orbit_y = planet1_orbit;\n\tstd::string planet2_orbit_y = planet2_orbit;\n\tstd::string planet1_orbit_z = planet1_orbit;\n\tstd::string planet2_orbit_z = planet2_orbit;\n\tstd::string planet1_orbit_w = planet1_orbit;\n\tstd::string planet2_orbit_w = planet2_orbit;\n\tstd::string planet1_orbit_x = planet1_orbit_x;\n\tstd::string planet2_orbit_x = planet2_orbit_x;\n\tstd::string planet1_orbit_y = planet1_orbit_y;\n\tstd::string planet2_orbit_y = planet2_orbit_y;\n\tstd::string planet1_orbit_z = planet1_orbit_z;\n\tstd::string planet2_orbit_z = planet2_orbit_z;\n\tstd::string planet1_orbit_w = planet1_orbit_w;\n\tstd::string planet2_orbit_w = planet2_orbit_w;\n\tstd::string planet1_orbit_y = planet1_orbit_y;\n\tstd::string planet2_orbit_y = planet2_orbit_y;\n\tstd::string planet1_orbit_z = planet1_orbit_z;\n\tstd::string planet2_orbit_z = planet2_orbit_z;\n\tstd::string planet1_orbit_w = planet1_orbit_w;\n\tstd::string planet2_orbit_w = planet2_orbit_w;\n\tstd::string planet1_orbit_x = planet1_orbit_x;\n\tstd::string planet2_orbit_x = planet2_orbit_x;\n\tstd::string planet1_orbit_y = planet1_orbit_y;\n\tstd::string planet2_orbit_y = planet2_orbit_y;\n\tstd::string planet1_orbit_z = planet1_orbit_z;\n\tstd::string planet2_orbit_z = planet2_orbit_z;\n\tstd::string planet1_orbit_w = planet1_orbit_w;\n\tstd::string planet2_orbit_w = planet2_orbit_w;\n\tstd::string planet1_orbit_x = planet1_orbit_x;\n\tstd::string planet2_orbit_x = planet2_orbit_x;\n\tstd::string planet1_orbit_y = planet1_orbit_y"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> sorted_list;\n    for (auto& str : lst) {\n        if (str.length() % 2 != 0) {\n            continue;\n        }\n        sorted_list.push_back(str);\n    }\n    return sorted_list;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    long res = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long w_or_x = 0;\n    long w_or_y = 0;\n    long w_or_z = 0;\n    long w_or_x_or_y = 0;\n    long w_or_y_or_z = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_y_or_z_or_x = 0;\n    long w_or_z_or_x_or_y = 0;\n    long w_or_x_or_y_or_z = 0;\n    long w_or_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long long sum = 0;\n    for (auto x : lst) {\n        sum += (x * x);\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    long total = 0;\n    for (long i = 0; i < game.size(); i++) {\n        total += game[i] - guess[i];\n    }\n    return total;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string str = \"\";\n  for (auto &extension : extensions) {\n    str += (extension.size() > 0) ? \" \" + extension : \"\";\n  }\n  return str;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    std::string s1 = a;\n    std::string s2 = b;\n    std::string s3 = s1.substr(0, s1.length() - 1);\n    std::string s4 = s2.substr(0, s2.length() - 1);\n    std::string s5 = s3.substr(0, s3.length() - 1);\n    std::string s6 = s4.substr(0, s4.length() - 1);\n    std::string s7 = s5.substr(0, s5.length() - 1);\n    std::string s8 = s6.substr(0, s6.length() - 1);\n    std::string s9 = s7.substr(0, s7.length() - 1);\n    std::string s10 = s8.substr(0, s8.length() - 1);\n    std::string s11 = s9.substr(0, s9.length() - 1);\n    std::string s12 = s10.substr(0, s10.length() - 1);\n    std::string s13 = s11.substr(0, s11.length() - 1);\n    std::string s14 = s12.substr(0, s12.length() - 1);\n    std::string s15 = s13.substr(0, s13.length() - 1);\n    std::string s16 = s14.substr(0, s14.length() - 1);\n    std::string s17 = s15.substr(0, s15.length() - 1);\n    std::string s18 = s16.substr(0, s16.length() - 1);\n    std::string s19 = s17.substr(0, s17.length() - 1);\n    std::string s20 = s18.substr(0, s18.length() - 1);\n    std::string s21 = s20.substr(0, s20.length() - 1);\n    std::string s22 = s21.substr(0, s21.length() - 1);\n    std::string s23 = s22.substr(0, s22.length() - 1);\n    std::string s24 = s23.substr(0, s23.length() - 1);\n    std::string s25 = s24.substr(0, s24.length() - 1);\n    std::string s26 = s25.substr(0, s25.length() - 1);\n    std::string s27 = s26.substr(0, s26.length() - 1);\n    std::string s28 = s27.substr(0, s27.length() - 1);\n    std::string s29 = s28.substr(0, s28.length() - 1);\n    std::string s30 = s29.substr(0, s29.length() - 1);\n    std::string s31 = s30.substr(0, s30.length() - 1);\n    std::string s32 = s31.substr(0, s31.length() - 1);\n    std::string s33 = s32.substr(0, s32"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_digits = num % 2;\n    long odd_digits = num / 2;\n    long even_digits_count = even_digits + odd_digits;\n    long odd_digits_count = odd_digits + even_digits;\n    return std::make_tuple(even_digits_count, odd_digits_count);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman_numeral = \"CMXCIX\";\n    std::string roman_numeral_str = roman_numeral;\n    std::string roman_numeral_str2 = roman_numeral;\n    std::string roman_numeral_str3 = roman_numeral;\n    std::string roman_numeral_str4 = roman_numeral;\n    std::string roman_numeral_str5 = roman_numeral;\n    std::string roman_numeral_str6 = roman_numeral;\n    std::string roman_numeral_str7 = roman_numeral;\n    std::string roman_numeral_str8 = roman_numeral;\n    std::string roman_numeral_str9 = roman_numeral;\n    std::string roman_numeral_str10 = roman_numeral;\n    std::string roman_numeral_str11 = roman_numeral;\n    std::string roman_numeral_str12 = roman_numeral;\n    std::string roman_numeral_str13 = roman_numeral;\n    std::string roman_numeral_str14 = roman_numeral;\n    std::string roman_numeral_str15 = roman_numeral;\n    std::string roman_numeral_str16 = roman_numeral;\n    std::string roman_numeral_str17 = roman_numeral;\n    std::string roman_numeral_str18 = roman_numeral;\n    std::string roman_numeral_str19 = roman_numeral;\n    std::string roman_numeral_str20 = roman_numeral;\n    std::string roman_numeral_str21 = roman_numeral;\n    std::string roman_numeral_str22 = roman_numeral;\n    std::string roman_numeral_str23 = roman_numeral;\n    std::string roman_numeral_str24 = roman_numeral;\n    std::string roman_numeral_str25 = roman_numeral;\n    std::string roman_numeral_str26 = roman_numeral;\n    std::string roman_numeral_str27 = roman_numeral;\n    std::string roman_numeral_str28 = roman_numeral;\n    std::string roman_numeral_str29 = roman_numeral;\n    std::string roman_numeral_str30 = roman_numeral;\n    std::string roman_numeral_str31 = roman_numeral;\n    std::string roman_numeral_str32 = roman_numeral;\n    std::string roman_numeral_str33 = roman_numeral;\n    std::string roman_numeral_str34 = roman_numeral;\n    std::string roman_numeral_str35 = roman_numeral;\n    std::string roman_numeral_str36 = roman_numeral;\n    std::string roman_numeral_str37 = roman_numeral;\n    std::string roman_numeral_str38 = roman_numeral;\n    std::string roman_numeral_str39 = roman_numeral;\n    std::string roman_numeral_str40 = roman_numeral;\n    std::string roman_numeral_str41 = roman_numeral;\n    std::string roman_numeral_str42 = roman_numeral;\n    std::string roman_numeral_str43 = roman_numeral;\n    std::string roman_numeral_str44 = roman_numeral;\n    std::string roman_numeral_str45 = roman_numeral;\n    std::string roman_numeral_str46 = roman_numeral;\n    std::string roman_numeral_str47 = roman_numeral;\n    std::string roman_numeral_str48 = roman_numeral;\n    std::string roman_numeral_"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (c > b && c > a) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (a > c && a > b) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (c > b && c > a) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c > a && c > b) {\n        return true;\n    }\n    if (a > b && a > c) {\n        return true;\n    }\n    if (b > a && b > c) {\n        return true;\n    }\n    if (c >"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    std::vector<std::string> words_sorted;\n    for (const auto& word : words) {\n        words_sorted.push_back(word);\n    }\n    for (const auto& word : words_sorted) {\n        if (word.length() > max_word.length()) {\n            max_word = word;\n        }\n    }\n    return max_word;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    std::vector<long> result;\n    if (number <= 0) {\n        return result;\n    }\n    if (number == 0) {\n        return result;\n    }\n    if (number == 1) {\n        return result;\n    }\n    if (number == 2) {\n        return result;\n    }\n    if (number == 3) {\n        return result;\n    }\n    if (number == 4) {\n        return result;\n    }\n    if (number == 5) {\n        return result;\n    }\n    if (number == 6) {\n        return result;\n    }\n    if (number == 7) {\n        return result;\n    }\n    if (number == 8) {\n        return result;\n    }\n    if (number == 9) {\n        return result;\n    }\n    if (number == 10) {\n        return result;\n    }\n    if (number == 11) {\n        return result;\n    }\n    if (number == 12) {\n        return result;\n    }\n    if (number == 13) {\n        return result;\n    }\n    if (number == 14) {\n        return result;\n    }\n    if (number == 15) {\n        return result;\n    }\n    if (number == 16) {\n        return result;\n    }\n    if (number == 17) {\n        return result;\n    }\n    if (number == 18) {\n        return result;\n    }\n    if (number == 19) {\n        return result;\n    }\n    if (number == 20) {\n        return result;\n    }\n    if (number == 21) {\n        return result;\n    }\n    if (number == 22) {\n        return result;\n    }\n    if (number == 23) {\n        return result;\n    }\n    if (number == 24) {\n        return result;\n    }\n    if (number == 25) {\n        return result;\n    }\n    if (number == 26) {\n        return result;\n    }\n    if (number == 27) {\n        return result;\n    }\n    if (number == 28) {\n        return result;\n    }\n    if (number == 29) {\n        return result;\n    }\n    if (number == 30) {\n        return result;\n    }\n    if (number == 31) {\n        return result;\n    }\n    if (number == 32) {\n        return result;\n    }\n    if (number == 33) {\n        return result;\n    }\n    if (number == 34) {\n        return result;\n    }\n    if (number == 35) {\n        return result;\n    }\n    if (number == 36) {\n        return result;\n    }\n    if (number == 37) {\n        return result;\n    }\n    if (number == 38) {\n        return result;\n    }\n    if (number == "], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n\tlong result = 0;\n\tfor (auto& operator : op) {\n\t\tresult += operator[](0);\n\t\tresult += operator[](1);\n\t\tresult += operator[](2);\n\t\tresult += operator[](3);\n\t\tresult += operator[](4);\n\t\tresult += operator[](5);\n\t}\n\treturn result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    std::string res;\n    std::string temp;\n    int i = 0;\n    while (i < s.size()) {\n        if (s[i] == ' ') {\n            i++;\n        } else {\n            temp = s.substr(i, s.size() - i);\n            res.push_back(temp);\n        }\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    std::string hash = \"\";\n    for (int i = 0; i < text.size(); i++) {\n        hash += text.at(i);\n    }\n    return hash;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    while (i < a && j < b) {\n        if (a % i == 0 && b % j == 0) {\n            result.push_back(a / i);\n            a /= i;\n            b /= i;\n        } else if (a % i == 0 && b % j == 0) {\n            result.push_back(b / i);\n            b /= i;\n            a /= i;\n        } else {\n            result.push_back(a / i);\n            a /= i;\n            b /= i;\n        }\n        i++;\n        j++;\n    }\n    return result;"]]